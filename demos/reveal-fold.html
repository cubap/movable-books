---
layout: default
title: "Reveal fold (pumpkin)"
permalink: /demos/reveal-fold.html
---

<div class="demo-reveal-fold">
  <h1>Reveal fold (pumpkin)</h1>
  <p>
    Drop two images in <code>assets/images/pumpkin/</code> named <code>closed.jpg</code> (flap covering) and <code>open.jpg</code> (revealed).
    Adjust the flap rectangle and hinge, then flip the flap to reveal the hidden area.
  </p>

  <div class="panel-and-controls">
    <div id="panel" class="image-panel" aria-live="polite" tabindex="0">
      <img id="base-open" alt="Open state (revealed)" crossorigin="anonymous" src="{{ '/assets/images/pumpkin/open.jpg' | relative_url }}" />
      <img id="base-closed" alt="Closed state (cover)" crossorigin="anonymous" src="{{ '/assets/images/pumpkin/closed.jpg' | relative_url }}" class="underlap" />

      <div id="overlay" class="overlay" aria-hidden="true">
        <svg id="overlaySvg" viewBox="0 0 1000 1000" preserveAspectRatio="none">
          <rect id="overlayRect" x="200" y="200" width="600" height="400" />
          <line id="overlayHinge" x1="200" y1="200" x2="800" y2="200" />
          <circle id="handleTL" class="handle" cx="200" cy="200" r="40" />
          <circle id="handleBR" class="handle" cx="800" cy="600" r="40" />
          <circle id="handleH1" class="handle" cx="200" cy="200" r="40" />
          <circle id="handleH2" class="handle" cx="800" cy="200" r="40" />
        </svg>
      </div>

      <div id="flap" class="flap" aria-label="Reveal flap">
        <div class="flap-inner">
          <img id="flap-img" alt="Flap region from closed image" crossorigin="anonymous" />
        </div>
      </div>
    </div>

    <div class="controls">
      <label for="angle">Angle (0° closed → 120° open)</label>
      <input id="angle" type="range" min="0" max="120" value="0" step="1" aria-label="Rotation angle" />
      <div class="ticks"><span>Closed</span><span>Open</span></div>
      <details class="nudge">
        <summary>Nudge (image px)</summary>
        <div class="nudge-grid">
          <label>X <input id="rx" type="number" step="1" /></label>
          <label>Y <input id="ry" type="number" step="1" /></label>
          <label>W <input id="rw" type="number" step="1" /></label>
          <label>H <input id="rh" type="number" step="1" /></label>
          <label>Hinge x1 <input id="hx1" type="number" step="1" /></label>
          <label>Hinge y1 <input id="hy1" type="number" step="1" /></label>
          <label>Hinge x2 <input id="hx2" type="number" step="1" /></label>
          <label>Hinge y2 <input id="hy2" type="number" step="1" /></label>
        </div>
        <div class="nudge-actions">
          <button type="button" id="btnCopy">Copy config</button>
          <button type="button" id="btnReset">Reset defaults</button>
        </div>
        <pre id="configOut" class="config-out" aria-live="polite"></pre>
      </details>
    </div>
  </div>

  <details>
    <summary>Details</summary>
    <ul>
      <li>Top image is the closed state; the flap crops a rectangular region from it and flips around a hinge to reveal the open image underneath.</li>
      <li>Use the handles or inputs to adjust the flap rectangle and hinge line.</li>
      <li>Images are expected at <code>assets/images/pumpkin/closed.jpg</code> and <code>assets/images/pumpkin/open.jpg</code>.</li>
    </ul>
  </details>
</div>

<style>
  .panel-and-controls { display: grid; grid-template-columns: 1fr; gap: 1rem; align-items: start; }
  @media (min-width: 980px){ .panel-and-controls { grid-template-columns: 2fr 1fr; } }
  .image-panel { position: relative; width: 100%; max-width: 900px; aspect-ratio: 1000 / 1000; background: #eee; border: 1px solid #ddd; overflow: hidden; }
  .image-panel img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; }
  .image-panel img.underlap { opacity: .92; }
  .controls { display: flex; flex-direction: column; gap: .5rem; }
  .ticks { display: flex; justify-content: space-between; font-size: .9rem; color: #555; }

  .flap { position: absolute; pointer-events: none; transform-style: preserve-3d; }
  .flap-inner { position: absolute; inset: 0; transform-style: preserve-3d; transition: transform 150ms linear; }
  .flap-inner img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; backface-visibility: hidden; }

  .overlay { position: absolute; inset: 0; }
  #overlaySvg { width: 100%; height: 100%; pointer-events: none; }
  #overlayRect { fill: none; stroke: hotpink; stroke-width: 6; opacity: .7; }
  #overlayHinge { stroke: hotpink; stroke-width: 6; stroke-dasharray: 16 8; opacity: .85; }
  .handle { fill: #fff; stroke: hotpink; stroke-width: 6; pointer-events: all; cursor: move; }

  .nudge-grid { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: .5rem; margin-top: .5rem; }
  .config-out { background: #f6f8fa; border: 1px solid #e1e4e8; padding: .5rem; border-radius: 4px; max-height: 12rem; overflow: auto; }
</style>

<script>
  const panel = document.getElementById('panel');
  const baseOpen = document.getElementById('base-open');
  const baseClosed = document.getElementById('base-closed');
  const angleInput = document.getElementById('angle');
  const overlaySvg = document.getElementById('overlaySvg');
  const overlayRect = document.getElementById('overlayRect');
  const overlayHinge = document.getElementById('overlayHinge');
  const hTL = document.getElementById('handleTL');
  const hBR = document.getElementById('handleBR');
  const hH1 = document.getElementById('handleH1');
  const hH2 = document.getElementById('handleH2');
  const flap = document.getElementById('flap');
  const flapInner = flap.querySelector('.flap-inner');
  const flapImg = document.getElementById('flap-img');
  const out = document.getElementById('configOut');
  const rxInput = document.getElementById('rx');
  const ryInput = document.getElementById('ry');
  const rwInput = document.getElementById('rw');
  const rhInput = document.getElementById('rh');
  const hx1Input = document.getElementById('hx1');
  const hy1Input = document.getElementById('hy1');
  const hx2Input = document.getElementById('hx2');
  const hy2Input = document.getElementById('hy2');
  const btnCopy = document.getElementById('btnCopy');
  const btnReset = document.getElementById('btnReset');

  // Image coordinate system (virtual canvas)
  const CANVAS_W = 1000, CANVAS_H = 1000;
  let rectState = { x: 200, y: 200, w: 600, h: 400 };
  let hingeState = { p1: { x: 200, y: 200 }, p2: { x: 800, y: 200 } };
  let drag = null; // { type: 'tl'|'br'|'h1'|'h2' }

  // Build IIIF crop url for the closed image; here we assume static files, so emulate with object-position and size
  const updateFlapImage = () => {
    // We scale the flap image using object-position and a background-like trick via CSS sizing
    // Compute the panel scale from canvas to pixels
    const rect = panel.getBoundingClientRect();
    const scaleX = rect.width / CANVAS_W;
    const scaleY = rect.height / CANVAS_H;

    // Position flap box
    flap.style.left = `${rectState.x * scaleX}px`;
    flap.style.top = `${rectState.y * scaleY}px`;
    flap.style.width = `${rectState.w * scaleX}px`;
    flap.style.height = `${rectState.h * scaleY}px`;

    // Show the closed image region; easiest is to set the flapImg to closed.jpg and shift via CSS transforms
    // Since object-fit: cover won't allow offset easily, we set it to contain by sizing the image to panel size and translate
    const offsetX = -rectState.x * scaleX;
    const offsetY = -rectState.y * scaleY;
    flapImg.src = baseClosed.src;
    flapImg.style.width = `${rect.width}px`;
    flapImg.style.height = `${rect.height}px`;
    flapImg.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
  };

  const layoutFlap = () => {
    // Compute transform origin based on hinge line
    const { p1, p2 } = hingeState;
    const dx = Math.abs(p2.x - p1.x);
    const dy = Math.abs(p2.y - p1.y);
    const axis = dx >= dy ? 'X' : 'Y'; // rotateX for horizontal hinge, rotateY for vertical

    const rect = panel.getBoundingClientRect();
    const scaleX = rect.width / CANVAS_W;
    const scaleY = rect.height / CANVAS_H;

    // Transform origin in flap box coords
    let ox = 0.5, oy = 0.5;
    if (axis === 'X') {
      const yH = (p1.y + p2.y) / 2;
      oy = (yH - rectState.y) / rectState.h;
      ox = 0.5;
    } else {
      const xH = (p1.x + p2.x) / 2;
      ox = (xH - rectState.x) / rectState.w;
      oy = 0.5;
    }
    flapInner.style.transformOrigin = `${(ox * 100).toFixed(3)}% ${(oy * 100).toFixed(3)}%`;
    flapInner.dataset.axis = axis;
  };

  const setRotation = (deg) => {
    const axis = flapInner.dataset.axis || 'X';
    flapInner.style.transform = axis === 'Y' ? `rotateY(${deg}deg)` : `rotateX(${deg}deg)`;
  };

  const updateOverlay = () => {
    overlayRect.setAttribute('x', String(rectState.x));
    overlayRect.setAttribute('y', String(rectState.y));
    overlayRect.setAttribute('width', String(rectState.w));
    overlayRect.setAttribute('height', String(rectState.h));
    overlayHinge.setAttribute('x1', String(hingeState.p1.x));
    overlayHinge.setAttribute('y1', String(hingeState.p1.y));
    overlayHinge.setAttribute('x2', String(hingeState.p2.x));
    overlayHinge.setAttribute('y2', String(hingeState.p2.y));
    hTL.setAttribute('cx', String(rectState.x));
    hTL.setAttribute('cy', String(rectState.y));
    hBR.setAttribute('cx', String(rectState.x + rectState.w));
    hBR.setAttribute('cy', String(rectState.y + rectState.h));
  };

  const syncInputs = () => {
    rxInput.value = String(Math.round(rectState.x));
    ryInput.value = String(Math.round(rectState.y));
    rwInput.value = String(Math.round(rectState.w));
    rhInput.value = String(Math.round(rectState.h));
    hx1Input.value = String(Math.round(hingeState.p1.x));
    hy1Input.value = String(Math.round(hingeState.p1.y));
    hx2Input.value = String(Math.round(hingeState.p2.x));
    hy2Input.value = String(Math.round(hingeState.p2.y));
    out.textContent = JSON.stringify({ flap: rectState, hinge: hingeState }, null, 2);
  };

  const applyFromInputs = () => {
    rectState = {
      x: Number(rxInput.value),
      y: Number(ryInput.value),
      w: Math.max(1, Number(rwInput.value)),
      h: Math.max(1, Number(rhInput.value))
    };
    hingeState = {
      p1: { x: Number(hx1Input.value), y: Number(hy1Input.value) },
      p2: { x: Number(hx2Input.value), y: Number(hy2Input.value) }
    };
    updateOverlay();
    updateFlapImage();
    layoutFlap();
  };

  // Dragging
  const toCanvas = (evt) => {
    const rect = overlaySvg.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (CANVAS_W / rect.width);
    const y = (evt.clientY - rect.top) * (CANVAS_H / rect.height);
    return { x, y };
  };
  const startDrag = (type) => (e) => { drag = { type }; overlaySvg.setPointerCapture(e.pointerId); e.preventDefault(); };
  const onMove = (e) => {
    if (!drag) return;
    const { x, y } = toCanvas(e);
    if (drag.type === 'tl') { // move top-left, keep bottom-right fixed
      const brx = rectState.x + rectState.w;
      const bry = rectState.y + rectState.h;
      rectState.x = Math.min(x, brx - 1);
      rectState.y = Math.min(y, bry - 1);
      rectState.w = Math.max(1, brx - rectState.x);
      rectState.h = Math.max(1, bry - rectState.y);
    } else if (drag.type === 'br') { // move bottom-right
      rectState.w = Math.max(1, x - rectState.x);
      rectState.h = Math.max(1, y - rectState.y);
    } else if (drag.type === 'h1') {
      hingeState.p1.x = x; hingeState.p1.y = y;
    } else if (drag.type === 'h2') {
      hingeState.p2.x = x; hingeState.p2.y = y;
    }
    updateOverlay();
    updateFlapImage();
    layoutFlap();
  };
  const endDrag = (e) => { if (!drag) return; try { overlaySvg.releasePointerCapture(e.pointerId); } catch {} drag = null; };

  hTL.addEventListener('pointerdown', startDrag('tl'));
  hBR.addEventListener('pointerdown', startDrag('br'));
  hH1.addEventListener('pointerdown', startDrag('h1'));
  hH2.addEventListener('pointerdown', startDrag('h2'));
  overlaySvg.addEventListener('pointermove', onMove);
  overlaySvg.addEventListener('pointerup', endDrag);
  overlaySvg.addEventListener('pointercancel', endDrag);

  // Init
  const hydrate = () => { updateOverlay(); syncInputs(); updateFlapImage(); layoutFlap(); };
  if (document.readyState === 'complete') hydrate(); else window.addEventListener('load', hydrate, { once: true });
  window.addEventListener('resize', () => { updateFlapImage(); layoutFlap(); });

  angleInput.addEventListener('input', (e) => setRotation(Number(e.target.value)));
  [rxInput, ryInput, rwInput, rhInput, hx1Input, hy1Input, hx2Input, hy2Input].forEach(inp => inp.addEventListener('input', applyFromInputs));
  btnCopy.addEventListener('click', async () => { const text = out.textContent || ''; try { await navigator.clipboard.writeText(text); } catch {} });
  btnReset.addEventListener('click', () => { rectState = { x: 200, y: 200, w: 600, h: 400 }; hingeState = { p1: { x: 200, y: 200 }, p2: { x: 800, y: 200 } }; hydrate(); });
</script>
